# The world beyond batch: Streaming 102

## 简介
欢迎回来！如果你错过了前一篇博文，The world beyond batch: Streaming 101，我强烈建议您先花一点时间阅读第一篇博文。第一篇博文介绍了我接下来讲述的这篇博文的一些必要的基础，我假设本篇博文的读者已经熟悉了前一篇博文内介绍的名词与概念。

同时，请注意本篇博文里包含了许多动画，所以如果读者直接打印的话将丢失一些内容的精华。

免责申明说完了，让party开始吧！首先简单回顾一下，上次我专注在三个主要的领域：**名词**，精确地定义了我们常说的比如“流计算”的概念；**批计算与流计算对比**，比较这两种计算模式理论上的能力，并且提出了流计算若想超越批计算，仅需考虑两件事：1.正确性2.推理时间的工具；和**数据处理模式**，探讨了批计算与流计算在处理有界与无界数据时的基本方法。

在这篇博文中，我希望在数据处理模式这个问题上更加深入，并且利用具体个案上下文更加更具体地深入挖掘。本篇博文的结构主要包括两部分：

* **温顾Streaming 101**: 简要回顾Streaming 101博文中阐述的概念，并通过具体例子证实之前的观点。
* **Streaming 102**：Streaming 101的伴生篇，通过一系列具体的案例，使之前介绍的概念更加具体。

当介绍完这篇博文时，我们将覆盖我认为打造一个健壮的乱序数据处理系统的核心原则与理念；这些就是推理时间的工具，这些工具使得流计算从真正意义上超越传统批量计算。

为了给您一点这些工具在现实中的感觉，我将使用Dataflow SDK（也就是Google Could Dataflow的API）的片段代码帮助阐述，辅以部分展示概念的动画。我使用Dataflow SDK而不是其他一些大家可能更熟悉的SDK，比方Spark Streaming或者Storm的理由是在今天没有其他系统的API在语义上能够表达我今天所要讲述的所有案例。好消息是其他系统正在往这个方向努力。一个更好的消息是我们（Google）如今给Apache Software Foundation提交了一个提案：创建一个Apache Dataflow孵化项目（联合包括data Artisans，Cloudera，Talend与一些其他公司），希望以Dataflow提供的健壮的无序处理语义为中心，创立一个开放的社区与生态。这将使得2016年成为一个非常有趣的年份，不好意思离题了。

本篇博文将不会探讨上次我承诺的流计算与批计算的对比；不好意思，我错误地低估了我想要在这篇博文中探讨的内容量与整理这些内容所需花费的时间。当下，我根本无法预估加入这个章节可能造成的延期。可能有所安慰的是，我最终在Strata+Hadoop 2015世界大会上分享了“海量数据处理的演化”这个议题（并可能在Strata+Hadoop世界大会2016伦敦上分享更新版），其中包含了许多我希望在对比环节中涵盖的内容。分享所使用的制作精美的幻灯片可以从这里获得，请自便。肯定的是，内容与对比部分会有所不同，但好歹凑合下:)

## 回顾与路线图
在Streaming 101中，我首先澄清了一些名词。首先区分了有界与无界数据。有界数据源拥有有限的大小，也就是通常我们所谓的“批”数据。无界数据源可能在大小上是无限的，也就是通常我们所谓的“流”数据。我尝试避免使用批数据与流数据，因为他们常常伴随特定的误导且受限的含义。

之后我定义了批计算与流计算引擎的区别：批引擎是那些在设计时仅考虑有界数据的引擎，而流引擎是设计时考虑无界数据的引擎。我的目标是仅在描述处理引擎时使用“批”与“流”这两个名词。

在名词解释之后，我涵盖了两个处理无界数据时非常重要而基本的概念。我首先提出了事件时间（事件发生的时间）与处理时间（事件对处理引擎可见的时间）关键的区别。这奠定了Streaming 101提出的一个重要观点的基石：如果你同时关心正确性与事件真正发生时间这个上下文，必须在事件真正发生的事件时间的角度上，而非数据被处理的处理时间的角度上分析数据。

之后，我介绍了**窗口**（也就是以临时的边界区隔数据集）这个概念，这是个处理理论上可能无穷无尽的无界数据的普遍方法。一些简单的窗口包括固定窗口与滑动窗口，但是一些更加复杂的窗口，比方会话窗口（由数据本身特性定义的窗口，比方由一段用户睡眠时间作为区隔，获得用户活跃时间作为会话的窗口）也有广泛的用途。

除了这两个概念，我们将更深刻地探讨三个更多的概念：

* **Watermarks**：一个Watermark是一个事件时间之前的输入已经全部完成的标记。一个带有x时间戳的Watermark有以下含义：“在事件时间x之前的所有事件均已可见”，这样，Watermark扮演了观察不可预见结束的无界数据源时数据进展这个指标的角色。

* **Trigger**：一个触发器是一种申明根据外界信号导致窗口的输出需实例化的机制。触发了提供了决定何时发送窗口输出的灵活性。同时提供了窗口在变化时数据多次可见的可能。反过来看，触发器使得多次修正窗口内的数据成为可能，这提供了根据上游数据源变化修正推测结果的能力，同时也提供了处理迟到数据的能力（比如手机传感器，当用户里离线时，他们记录了手机各种各样的信息，而后当用户重新在线时，把这些离线时收集的数据继续传送上报）。

* **Accumulation**：一种accumulation模式指定了同一个窗口内多个数据记录的关系。这些记录可能完全不相关，也就是他们作为时间轴上完全独立增量，抑或他们之间可能重叠。不同的accumulation模式拥有不同的语义与不同的成本，因此需要从多种使用案例中寻找到合适的那种。

最后，因为我希望使得大家更容易理解这些概念的关联，我们将会利用以下4个问题温故知新，这些问题对于处理所有无界数据的场景都非常关键：

（未完待续...）
